diff --git a/cmd/nerdctl/container_run_network_linux_test.go b/cmd/nerdctl/container_run_network_linux_test.go
index 95fdbc41..fa163486 100644
--- a/cmd/nerdctl/container_run_network_linux_test.go
+++ b/cmd/nerdctl/container_run_network_linux_test.go
@@ -20,15 +20,20 @@ import (
 	"fmt"
 	"io"
 	"net"
+	"os/exec"
 	"regexp"
 	"runtime"
 	"strings"
 	"testing"
+	"time"
 
+	"github.com/containerd/containerd/pkg/netns"
 	"github.com/containerd/errdefs"
 	"github.com/containerd/nerdctl/pkg/rootlessutil"
 	"github.com/containerd/nerdctl/pkg/testutil"
 	"github.com/containerd/nerdctl/pkg/testutil/nettestutil"
+	"github.com/stretchr/testify/require"
+	"github.com/vishvananda/netlink"
 	"gotest.tools/v3/assert"
 	"gotest.tools/v3/icmd"
 )
@@ -451,6 +456,76 @@ func TestSharedNetworkStack(t *testing.T) {
 		AssertOutContains(testutil.NginxAlpineIndexHTMLSnippet)
 }
 
+func TestSharedNetworkWithNone(t *testing.T) {
+	if runtime.GOOS != "linux" {
+		t.Skip("--network=container:<container name|id> only supports linux now")
+	}
+	base := testutil.NewBase(t)
+
+	containerName := testutil.Identifier(t)
+	t.Cleanup(func() {
+		base.Cmd("rm", "-f", containerName).Run()
+	})
+	base.Cmd("run", "-d", "--name", containerName, "--network", "none",
+		testutil.NginxAlpineImage).AssertOK()
+	base.EnsureContainerStarted(containerName)
+
+	containerNameJoin := testutil.Identifier(t) + "-network"
+	t.Cleanup(func() {
+		base.Cmd("rm", "-f", containerNameJoin).Run()
+	})
+	base.Cmd("run",
+		"-d",
+		"--name", containerNameJoin,
+		"--network=container:"+containerName,
+		testutil.CommonImage,
+		"sleep", "infinity").AssertOK()
+
+	base.Cmd("exec", containerNameJoin, "wget", "-qO-", "http://127.0.0.1:80").
+		AssertOutContains(testutil.NginxAlpineIndexHTMLSnippet)
+
+	base.Cmd("restart", containerName).AssertOK()
+	base.Cmd("stop", "--time=1", containerNameJoin).AssertOK()
+	base.Cmd("start", containerNameJoin).AssertOK()
+	base.Cmd("exec", containerNameJoin, "wget", "-qO-", "http://127.0.0.1:80").
+		AssertOutContains(testutil.NginxAlpineIndexHTMLSnippet)
+}
+
+func TestRunContainerInExistingNetNS(t *testing.T) {
+	if rootlessutil.IsRootless() {
+		t.Skip("Can't create new netns in rootless mode")
+	}
+	testutil.DockerIncompatible(t)
+	base := testutil.NewBase(t)
+
+	netNS, err := netns.NewNetNS(t.TempDir() + "/netns")
+	assert.NilError(t, err)
+	err = netNS.Do(func(netns ns.NetNS) error {
+		loopback, err := netlink.LinkByName("lo")
+		assert.NilError(t, err)
+		err = netlink.LinkSetUp(loopback)
+		assert.NilError(t, err)
+		return nil
+	})
+	assert.NilError(t, err)
+	defer netNS.Remove()
+
+	containerName := testutil.Identifier(t)
+	defer base.Cmd("rm", "-f", containerName).AssertOK()
+	base.Cmd("run", "-d", "--name", containerName,
+		"--network=ns:"+netNS.GetPath(), testutil.NginxAlpineImage).AssertOK()
+	base.EnsureContainerStarted(containerName)
+	time.Sleep(3 * time.Second)
+
+	err = netNS.Do(func(netns ns.NetNS) error {
+		stdout, err := exec.Command("curl", "-s", "http://127.0.0.1:80").Output()
+		assert.NilError(t, err)
+		assert.Assert(t, strings.Contains(string(stdout), testutil.NginxAlpineIndexHTMLSnippet))
+		return nil
+	})
+	assert.NilError(t, err)
+}
+
 func TestRunContainerWithMACAddress(t *testing.T) {
 	base := testutil.NewBase(t)
 	tID := testutil.Identifier(t)
@@ -511,6 +586,8 @@ func TestHostsFileMounts(t *testing.T) {
 		"sh", "-euxc", "echo >> /etc/hosts").AssertOK()
 	base.Cmd("run", "--rm", "-v", "/etc/hosts:/etc/hosts", "--network", "host", testutil.CommonImage,
 		"sh", "-euxc", "head -n -1 /etc/hosts > temp && cat temp > /etc/hosts").AssertOK()
+	base.Cmd("run", "--rm", "--network", "none", testutil.CommonImage,
+		"sh", "-euxc", "echo >> /etc/hosts").AssertOK()
 
 	base.Cmd("run", "--rm", testutil.CommonImage,
 		"sh", "-euxc", "echo >> /etc/resolv.conf").AssertOK()
@@ -523,6 +600,8 @@ func TestHostsFileMounts(t *testing.T) {
 		"sh", "-euxc", "echo >> /etc/resolv.conf").AssertOK()
 	base.Cmd("run", "--rm", "-v", "/etc/resolv.conf:/etc/resolv.conf", "--network", "host", testutil.CommonImage,
 		"sh", "-euxc", "head -n -1 /etc/resolv.conf > temp && cat temp > /etc/resolv.conf").AssertOK()
+	base.Cmd("run", "--rm", "--network", "host", testutil.CommonImage,
+		"sh", "-euxc", "echo >> /etc/resolv.conf").AssertOK()
 }
 
 func TestRunContainerWithStaticIP6(t *testing.T) {
@@ -594,3 +673,39 @@ func TestRunContainerWithStaticIP6(t *testing.T) {
 		})
 	}
 }
+
+func TestNoneNetworkStaticConfigs(t *testing.T) {
+	testutil.DockerIncompatible(t)
+	base := testutil.NewBase(t)
+
+	//TODO: Add tests for --dns --dns-search --add-host
+
+	// If running on Linux, verify /etc/hostname is correctly set
+	if runtime.GOOS == "linux" {
+		containerHostName := testutil.Identifier(t)
+		cmd := base.Cmd("run", "--rm", "--net", "none", "--hostname", containerHostName, testutil.CommonImage, "cat", "/etc/hostname")
+		output := cmd.Run().Combined()
+		hostname := strings.TrimSpace(output)
+
+		if len(containerHostName) > 12 {
+			assert.Equal(t, containerHostName[:12], hostname[:12])
+		} else {
+			assert.Equal(t, containerHostName, hostname[:12])
+		}
+
+		containerName := testutil.Identifier(t) + "-id"
+		t.Cleanup(func() {
+			base.Cmd("rm", "-f", containerName).Run()
+		})
+		cmd = base.Cmd("run", "-d", "--net", "none", "--name", containerName, testutil.CommonImage, "sleep", "infinity")
+		output = cmd.Run().Combined()
+		containerIDShort := strings.TrimSpace(output)[:12]
+
+		cmd = base.Cmd("exec", containerName, "cat", "/etc/hostname")
+		output = cmd.Run().Combined()
+		containerHostName = strings.TrimSpace(output)
+
+		assert.Equal(t, containerHostName, containerIDShort)
+
+	}
+}
diff --git a/go.mod b/go.mod
index c2c92cea..ec06dfb9 100644
--- a/go.mod
+++ b/go.mod
@@ -127,7 +127,7 @@ require (
 	github.com/pelletier/go-toml v1.9.5 // indirect
 	github.com/philhofer/fwd v1.1.1 // indirect
 	github.com/pkg/errors v0.9.1 // indirect
-	github.com/sirupsen/logrus v1.9.3 // indirect
+	github.com/sirupsen/logrus v1.9.3
 	github.com/spaolacci/murmur3 v1.1.0 // indirect
 	github.com/stefanberger/go-pkcs11uri v0.0.0-20230803200340-78284954bff6 // indirect
 	github.com/tidwall/match v1.1.1 // indirect
diff --git a/pkg/cmd/container/create.go b/pkg/cmd/container/create.go
index 953c07b1..48be83fd 100644
--- a/pkg/cmd/container/create.go
+++ b/pkg/cmd/container/create.go
@@ -310,10 +310,7 @@ func Create(ctx context.Context, client *containerd.Client, args []string, netMa
 
 	c, containerErr := client.NewContainer(ctx, id, cOpts...)
 	var netSetupErr error
-	// NOTE: on non-Windows platforms, network setup is performed by OCI hooks.
-	// Seeing as though Windows does not currently support OCI hooks, we must explicitly
-	// perform network setup/teardown in the main nerdctl executable.
-	if containerErr == nil && runtime.GOOS == "windows" {
+	if containerErr == nil {
 		netSetupErr = netManager.SetupNetworking(ctx, id)
 		if netSetupErr != nil {
 			log.G(ctx).WithError(netSetupErr).Warnf("networking setup error has occurred")
diff --git a/pkg/containerutil/container_network_manager.go b/pkg/containerutil/container_network_manager.go
index b86870a4..0813b6ff 100644
--- a/pkg/containerutil/container_network_manager.go
+++ b/pkg/containerutil/container_network_manager.go
@@ -38,6 +38,7 @@ import (
 	"github.com/containerd/nerdctl/pkg/mountutil"
 	"github.com/containerd/nerdctl/pkg/netutil"
 	"github.com/containerd/nerdctl/pkg/netutil/nettype"
+	"github.com/containerd/nerdctl/pkg/resolvconf"
 	"github.com/containerd/nerdctl/pkg/strutil"
 	"github.com/opencontainers/runtime-spec/specs-go"
 )
@@ -154,13 +155,82 @@ func (m *noneNetworkManager) VerifyNetworkOptions(_ context.Context) error {
 }
 
 // SetupNetworking Performs setup actions required for the container with the given ID.
-func (m *noneNetworkManager) SetupNetworking(_ context.Context, _ string) error {
+func (m *noneNetworkManager) SetupNetworking(ctx context.Context, containerID string) error {
+
+	// Retrieve the container
+	container, err := m.client.ContainerService().Get(ctx, containerID)
+	if err != nil {
+		return err
+	}
+
+	// Get the dataStore
+	dataStore, err := clientutil.DataStore(m.globalOptions.DataRoot, m.globalOptions.Address)
+	if err != nil {
+		return err
+	}
+
+	// Get the hostsStore
+	hs, err := hostsstore.NewStore(dataStore)
+	if err != nil {
+		return err
+	}
+
+	// Get extra-hosts
+	extraHostsJSON := container.Labels[labels.ExtraHosts]
+	var extraHosts []string
+	if err = json.Unmarshal([]byte(extraHostsJSON), &extraHosts); err != nil {
+		return err
+	}
+
+	hosts := make(map[string]string)
+	for _, host := range extraHosts {
+		if v := strings.SplitN(host, ":", 2); len(v) == 2 {
+			hosts[v[0]] = v[1]
+		}
+	}
+
+	// Prep the meta
+	hsMeta := hostsstore.Meta{
+		ID:         container.ID,
+		Hostname:   container.Labels[labels.Hostname],
+		ExtraHosts: hosts,
+		Name:       container.Labels[labels.Name],
+		Namespace:  container.Labels[labels.Namespace],
+	}
+
+	// Save the meta information
+	if err = hs.Acquire(hsMeta); err != nil {
+		return err
+	}
+
 	return nil
 }
 
 // CleanupNetworking Performs any required cleanup actions for the given container.
 // Should only be called to revert any setup steps performed in SetupNetworking.
-func (m *noneNetworkManager) CleanupNetworking(_ context.Context, _ containerd.Container) error {
+func (m *noneNetworkManager) CleanupNetworking(ctx context.Context, container containerd.Container) error {
+	// Get the dataStore
+	dataStore, err := clientutil.DataStore(m.globalOptions.DataRoot, m.globalOptions.Address)
+	if err != nil {
+		return err
+	}
+
+	// Get labels
+	lbls, err := container.Labels(ctx)
+	if err != nil {
+		return err
+	}
+
+	// Get the hostsStore
+	hs, err := hostsstore.NewStore(dataStore)
+	if err != nil {
+		return err
+	}
+
+	// Release
+	if err = hs.Release(container.ID(), lbls[labels.Namespace]); err != nil {
+		return err
+	}
 	return nil
 }
 
@@ -169,11 +239,81 @@ func (m *noneNetworkManager) InternalNetworkingOptionLabels(_ context.Context) (
 	return m.netOpts, nil
 }
 
+// WriteContentToHostsFile writes the given content to the specified path.
+func WriteContentToHostsFile(path string, content []byte) error {
+	// Write the content to the specified path (overwrites if the file exists)
+	if err := os.WriteFile(path, content, 0644); err != nil {
+		return err
+	}
+	return nil
+}
+
 // ContainerNetworkingOpts Returns a slice of `oci.SpecOpts` and `containerd.NewContainerOpts` which represent
 // the network specs which need to be applied to the container with the given ID.
-func (m *noneNetworkManager) ContainerNetworkingOpts(_ context.Context, _ string) ([]oci.SpecOpts, []containerd.NewContainerOpts, error) {
+func (m *noneNetworkManager) ContainerNetworkingOpts(_ context.Context, containerID string) ([]oci.SpecOpts, []containerd.NewContainerOpts, error) {
 	// No options to return if no network settings are provided.
-	return []oci.SpecOpts{}, []containerd.NewContainerOpts{}, nil
+	dataStore, err := clientutil.DataStore(m.globalOptions.DataRoot, m.globalOptions.Address)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	stateDir, err := ContainerStateDirPath(m.globalOptions.Namespace, dataStore, containerID)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	resolvConfPath := filepath.Join(stateDir, "resolv.conf")
+	dns := []string{"127.0.0.1"}
+	dnsSearch := []string{}
+	dnsOptions := []string{}
+
+	if len(m.netOpts.DNSServers) > 0 {
+		dns = m.netOpts.DNSServers
+	}
+	if len(m.netOpts.DNSSearchDomains) > 0 {
+		dnsSearch = m.netOpts.DNSSearchDomains
+	}
+	if len(m.netOpts.DNSResolvConfOptions) > 0 {
+		dnsOptions = m.netOpts.DNSResolvConfOptions
+	}
+
+	// Call the Build function
+	_, err = resolvconf.Build(resolvConfPath, dns, dnsSearch, dnsOptions)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	etcHostsPath, err := hostsstore.AllocHostsFile(dataStore, m.globalOptions.Namespace, containerID)
+	if err != nil {
+		return nil, nil, err
+	}
+
+	specs := []oci.SpecOpts{
+		withDedupMounts("/etc/hosts", withCustomHosts(etcHostsPath)),
+		withDedupMounts("/etc/resolv.conf", withCustomResolvConf(resolvConfPath)),
+	}
+
+	// `/etc/hostname` does not exist on FreeBSD
+	if runtime.GOOS == "linux" {
+		// If no hostname is set, default to first 12 characters of the container ID.
+		hostname := m.netOpts.Hostname
+		if hostname == "" {
+			hostname = containerID
+			if len(hostname) > 12 {
+				hostname = hostname[0:12]
+			}
+		}
+		m.netOpts.Hostname = hostname
+
+		hostnameOpts, err := writeEtcHostnameForContainer(m.globalOptions, m.netOpts.Hostname, containerID)
+		if err != nil {
+			return nil, nil, err
+		}
+		if hostnameOpts != nil {
+			specs = append(specs, hostnameOpts...)
+		}
+	}
+	return specs, []containerd.NewContainerOpts{}, nil
 }
 
 // types.NetworkOptionsManager implementation for container networking settings.
